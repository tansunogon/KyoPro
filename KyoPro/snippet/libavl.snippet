<?xml version="1.0" encoding="utf-8"?>
<CodeSnippets xmlns="http://schemas.microsoft.com/VisualStudio/2005/CodeSnippet">
  <CodeSnippet Format="1.0.0">
    <Header>
      <SnippetTypes>
        <SnippetType>Expansion</SnippetType>
      </SnippetTypes>
      <Title>libavl</Title>
      <Author>
      </Author>
      <Description>
      </Description>
      <HelpUrl>
      </HelpUrl>
      <Shortcut>libavl</Shortcut>
    </Header>
    <Snippet>
      <Code Language="cpp" Delimiter="$"><![CDATA[// AVL Tree
//
// AVL Tree can solve the following problems:
//     Initially assume that for each element in an infinite sequence is
//     the identity value IDENT:
//             For all k, A[k] = IDENT (k: index or key)
//         For Example, if you are considering numbers and add operation,
//         the identity element is 0. So,
//             For all k, A[k] = 0     (k: index or key)
//     Process queries of the followings.
//         1. Replace value V at K
//            input: K, V
//            effect: A[K] = V
//         2. Apply binary operation at K with value V
//            input: K, V
//            effect: A[K] = A[K] Op V
//            For example, if Op = add, then apply
//                A[K] += V
//         3. Calculate range value
//            input: L, R
//            output: Op_{L<=k<=R} A[k]
//            For example, if Op = add, then calculate
//                sum_{L<=k<=R} A[k]
//         4. Search minimum range
//            input: L, function F: value -> {true, false}
//                   Function F should have the following property:
//                       For all p, q. L < p < q.
//                           F(Op_{L<=k<=q} A[k]) => F(Op_{L<=k<=p} A[k])
//            output: minimum r, where F(Op_{L<=k<=r} A[k])
//            For example, if Op = add and F(v)=(10<=v), then search
//                minimum r, where 10 <= sum_{L<=k<=r} A[k]
//
// AVL Tree can solve the same problems as Segment Tree does.
// Segment Tree sometimes needs coordinate compression,
// but AVL tree has the advantage that there is no need to compress coordinates.
//
// Implemented by tansu
template <class Key, class Monoid, Monoid IDENT, class Op>
struct AVLTreeNode {
	AVLTreeNode *left;
	AVLTreeNode *right;
	Key key;
	Monoid value;
	Monoid sum_of_value;
	int rank;
	AVLTreeNode(Key key, Monoid value) :
		left(nullptr),
		right(nullptr),
		key(key),
		value(value),
		sum_of_value(value),
		rank(1)
	{
	}
	~AVLTreeNode() { delete left; delete right; }
	// 全ての要素の和を返す
	Monoid sum() const
	{
		return sum_of_value;
	}
	// key 以下の value の和を返す
	Monoid lower_sum(Key key) const
	{
		Monoid s = IDENT;
		AVLTreeNode *node = this;
		while (node) {
			if (!(key < node->key) && !(node->key < key)) {
				s = Op()(s, node->left ? node->left->sum() : IDENT);
				s = Op()(s, node->value);
				break;
			} else if (key < node->key) {
				node = node->left;
			} else {
				s = Op()(s, node->left ? node->left->sum() : IDENT);
				s = Op()(s, node->value);
				node = node->right;
			}
		}
		return s;
	}
	// key 以上の value の和を返す
	Monoid upper_sum(Key key) const
	{
		Monoid s = IDENT;
		AVLTreeNode *node = this;
		while (node) {
			if (!(key < node->key) && !(node->key < key)) {
				s = Op()(s, node->value);
				s = Op()(s, node->right ? node->right->sum() : IDENT);
				break;
			} else if (key < node->key) {
				s = Op()(s, node->value);
				s = Op()(s, node->right ? node->right->sum() : IDENT);
				node = node->left;
			} else {
				node = node->right;
			}
		}
		return s;
	}
	Monoid range_sum(Key l_key, Key r_key) const
	{
		AVLTreeNode *node = this;
		while (node) {
			if (node->key < l_key) {
				node = node->left;
			} else if (!(l_key < node->key)) { // node->key == l_key
				return node->upper_sum(r_key);
			} else if (node->key < r_key) { // l_key < node->key < r_key
				Monoid s = node->value;
				s = Op()(s, node->left ? node->left->upper_sum() : IDENT);
				s = Op()(s, node->right ? node->right->lower_sum() : IDENT);
				return s;
			} else if (!(r_key < node->key)) { // node->key == r_key
				return node->lower_sum(l_key);
			} else { // r_key < node->key
				node = node->right;
			}
		}
		return IDENT;
	}
	Key min_range(Key l_key, function<bool(Monoid)> f) const
	{

	}
	Key min_range_r(Key r_key, function<bool(Monoid)> f) const
	{

	}
	// key に value を加算する
	// 該当するノードのポインタを返す
	AVLTreeNode *insert(Key key, Monoid value, bool replace = false)
	{
		AVLTreeNode *ret;
		if (!(key < this->key) && !(this->key < key)) {
			if (replace) {
				this->value = value;
				update_sum();
			} else {
				this->value = Op()(this->value, value);
				this->sum_of_value = Op()(this->sum_of_value, value);
			}
			return this;
		} else if (key < this->key) {
			if (this->left) {
				ret = this->left->insert(key, value);
			} else {
				ret = this->left = new AVLTreeNode(key, value);
			}
		} else {
			if (this->right) {
				ret = this->right->insert(key, value);
			} else {
				ret = this->right = new AVLTreeNode(key, value);
			}
		}
		update_sum();
		int l_rank = left ? left->rank : 0;
		int r_rank = right ? right->rank : 0;
		this->rank = max(l_rank, r_rank) + 1;

		if (l_rank > r_rank + 1) {
			rotate_l();
		} else if (r_rank > l_rank + 1) {
			rotate_r();
		}

		return ret;
	}
	void update_sum()
	{
		Monoid l_sum = left ? left->sum() : IDENT;
		Monoid r_sum = right ? right->sum() : IDENT;
		sum_of_value = Op()(Op()(value, l_sum), r_sum);
	}
	void update_rank()
	{
		int l_rank = left ? left->rank : 0;
		int r_rank = right ? right->rank : 0;
		rank = max(l_rank, r_rank) + 1;
	}
	// left => new root
	void rotate_l()
	{
		AVLTreeNode *ll = this->left->left;
		AVLTreeNode *lr = this->left->right;
		AVLTreeNode *r = this->right;

		AVLTreeNode *root = this;
		AVLTreeNode *node = this->left;
		root->left = ll;
		root->right = node;
		node->left = lr;
		node->right = r;
		swap(root->key, node->key);
		swap(root->value, node->value);
		node->update_sum();
		node->update_rank();
		root->update_sum();
		root->update_rank();
	}
	// right => new root
	void rotate_r()
	{
		AVLTreeNode *rl = this->right->left;
		AVLTreeNode *rr = this->right->right;
		AVLTreeNode *l = this->left;

		AVLTreeNode *root = this;
		AVLTreeNode *node = this->right;
		root->left = node;
		root->right = rr;
		node->left = l;
		node->right = rl;
		swap(root->key, node->key);
		swap(root->value, node->value);
		node->update_sum();
		node->update_rank();
		root->update_sum();
		root->update_rank();
	}
};
template <class Key, class Monoid, Monoid IDENT, class Op>
struct AVLTreeIterator {
	using Node = AVLTreeNode<Key, Monoid, IDENT, Op>;
	vector<Node *> stack;
	AVLTreeIterator(Node *node)
	{
		while (node) {
			stack.push_back(node);
			node = node->left;
		}
	}
	AVLTreeIterator &operator++()
	{
		auto node = stack.back();
		if (node->right) {
			node = node->right;
			while (node) {
				stack.push_back(node);
				node = node->left;
			}
			return *this;
		}
		stack.pop_back();
		while (!stack.empty() && stack.back() != nullptr && stack.back()->right == node) {
			node = stack.back();
			stack.pop_back();
		}
		return *this;
	}
	bool operator==(const AVLTreeIterator &rhs) const
	{
		return (stack.empty() && rhs.stack.empty())
			|| (stack.size() == rhs.stack.size() && stack.back() == rhs.stack.back());
	}
	bool operator!=(const AVLTreeIterator &rhs) const
	{
		return !operator==(rhs);
	}
	Node *operator->() const
	{
		return stack.back();
	}
	pair<Key, Monoid> operator*() const
	{
		return make_pair(stack.back()->key, stack.back()->value);
	}
};
template <class Key = int, class Monoid = int, Monoid IDENT = Monoid(), class Op = plus<Monoid>>
struct AVLTree {
	using Node = AVLTreeNode<Key, Monoid, IDENT, Op>;
	using iterator = AVLTreeIterator<Key, Monoid, IDENT, Op>;
	Node *root;
	AVLTree() : root(nullptr) {}
	~AVLTree() { delete root; }
	// 全ての要素の和を返す
	Monoid sum() const
	{
		if (root) {
			return root->sum();
		} else {
			return IDENT;
		}
	}
	// key 未満の value の和を返す
	Monoid lower_sum(Key key) const
	{
		if (root) {
			return root->lower_sum(key);
		} else {
			return IDENT;
		}
	}
	// key に value を加算する
	// 該当するノードのポインタを返す
	Node *insert(Key key, Monoid value, bool replace = false)
	{
		if (root) {
			return root->insert(key, value, replace);
		} else {
			root = new Node(key, value);
			return root;
		}
	}
	// key の要素を削除する (実際には IDENT で置き換える)
	// 該当するノードのポインタを返す
	Node *erase(Key key, Monoid value) const
	{
		if (root) {
			return root->insert(key, IDENT, replace = true);
		} else {
			return nullptr;
		}
	}
	iterator begin() const
	{
		return iterator(root);
	}
	iterator end() const
	{
		return iterator(nullptr);
	}
};
$end$]]></Code>
    </Snippet>
  </CodeSnippet>
</CodeSnippets>